package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"strings"

	"github.com/orisano/subflag"
	"github.com/pkg/errors"
	"golang.org/x/tools/imports"
)

type InterfacerCommand struct {
	File string
}

func (c *InterfacerCommand) FlagSet() *flag.FlagSet {
	fs := flag.NewFlagSet("interfacer", flag.ExitOnError)
	fs.StringVar(&c.File, "f", os.Getenv("GOFILE"), "source path (required, default: $GOFILE)")
	return fs
}

func (c *InterfacerCommand) Run(args []string) error {
	if c.File == "" {
		return subflag.ErrInvalidArguments
	}
	f, err := parser.ParseFile(token.NewFileSet(), c.File, nil, parser.AllErrors)
	if err != nil {
		return errors.Wrapf(err, "failed to parse source (path=%v)", c.File)
	}
	st := firstStruct(f)
	if st == nil {
		return errors.Errorf("not found struct in file (path=%v)", c.File)
	}
	interfaceName := strings.Title(st.Name.Name)
	methods := getMethods(f, st)

	interfaceDecl := toInterfaceDecl(interfaceName, methods)
	constructorDecl := toConstructorDecl(interfaceName, st)

	genFilename := strings.TrimSuffix(c.File, ".go") + "_gen.go"
	gf := &ast.File{
		Name:    f.Name,
		Imports: f.Imports,
		Decls: []ast.Decl{
			interfaceDecl,
			constructorDecl,
		},
	}
	var buf bytes.Buffer
	printer.Fprint(&buf, token.NewFileSet(), gf)
	b, err := imports.Process(genFilename, buf.Bytes(), nil)
	if err != nil {
		return errors.Wrapf(err, "failed to process imports (path=%v)", c.File)
	}

	w, err := os.Create(genFilename)
	if err != nil {
		return errors.Wrap(err, "failed to generate file")
	}
	defer w.Close()

	fmt.Fprintln(w, `// code generated by "cg interfacer"; DO NOT EDIT.`)
	if _, err := w.Write(b); err != nil {
		return errors.Wrapf(err, "failed to write (path=%v)", genFilename)
	}

	return nil
}

func firstStruct(f *ast.File) *ast.TypeSpec {
	for _, decl := range f.Decls {
		gd, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if gd.Tok != token.TYPE {
			continue
		}
		for _, spec := range gd.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if _, ok := ts.Type.(*ast.StructType); ok {
				return ts
			}
		}
	}
	return nil
}

func getMethods(f *ast.File, st *ast.TypeSpec) []*ast.FuncDecl {
	var methods []*ast.FuncDecl
	for _, decl := range f.Decls {
		fd, ok := decl.(*ast.FuncDecl)
		if !ok {
			continue
		}
		if !fd.Name.IsExported() {
			continue
		}
		if fd.Recv == nil {
			continue
		}
		rt := fd.Recv.List[0].Type
		if se, ok := rt.(*ast.StarExpr); ok {
			rt = se.X
		}
		if st.Name.Name != rt.(*ast.Ident).Name {
			continue
		}
		methods = append(methods, fd)
	}
	return methods
}

func toInterfaceDecl(name string, methods []*ast.FuncDecl) *ast.GenDecl {
	fl := &ast.FieldList{}
	for _, method := range methods {
		fl.List = append(fl.List, &ast.Field{
			Names: []*ast.Ident{method.Name},
			Type:  method.Type,
		})
	}
	return &ast.GenDecl{
		Tok: token.TYPE,
		Specs: []ast.Spec{
			&ast.TypeSpec{
				Name: ast.NewIdent(name),
				Type: &ast.InterfaceType{
					Methods: fl,
				},
			},
		},
	}
}

func toConstructorDecl(interfaceName string, structType *ast.TypeSpec) *ast.FuncDecl {
	return &ast.FuncDecl{
		Name: ast.NewIdent("New" + interfaceName),
		Type: &ast.FuncType{
			Params: structType.Type.(*ast.StructType).Fields,
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: ast.NewIdent(interfaceName)},
					{Type: ast.NewIdent("error")},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						newInstanceExpr(structType),
						ast.NewIdent("nil"),
					},
				},
			},
		},
	}
}

func newInstanceExpr(structType *ast.TypeSpec) ast.Expr {
	cl := &ast.CompositeLit{
		Type: structType.Name,
	}

	st := structType.Type.(*ast.StructType)
	if st.Fields != nil {
		for _, f := range st.Fields.List {
			cl.Elts = append(cl.Elts, &ast.KeyValueExpr{
				Key:   f.Names[0],
				Value: f.Names[0],
			})
		}
	}
	return &ast.UnaryExpr{
		Op: token.AND,
		X:  cl,
	}
}
